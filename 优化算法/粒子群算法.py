import numpy as np
import sko.PSO as PSO
import matplotlib.pyplot as plt
'''
优势：
1. 全局搜索能力强：PSO通过群体协作搜索，能够有效避免陷入局部最优解。
2. 参数较少：相比其他优化算法，PSO需要调整的参数较少，降低了调参难度。
3. 适应性强：PSO可以应用于各种类型的优化问题，包括连续和离散优化问题。
4. 并行计算能力：PSO算法天然适合并行计算，可以利用多核处理器提高计算效率。
5. 函数不可导也能使用。
劣势：
1. 收敛速度不稳定：PSO的收敛速度可能较慢，尤其是在复杂的高维问题中。
2. 易陷入局部最优：尽管PSO具有全局搜索能力，但在某些情况下仍可能陷入局部最优解。
3. 参数敏感性：PSO的性能对参数设置较为敏感，不同参数组合可能导致截然不同的结果。
4. 缺乏理论支持：相比其他优化算法，PSO缺乏系统的理论分析，导致其性能难以预测。
5. 适用范围有限：PSO在某些特定类型的问题上表现不佳，如高度非线性或多峰问题。
'''
def func(x):
    ans=x[0]**2 + x[1]**2 + 1
    '''构造惩罚函数'''
    cst=max(0,5-x[0]-x[1])
    pnt=1000*cst
    return ans+pnt
'''
复杂情况可以自定义类继承自PSO类，然后重写其中的方法以实现更复杂的功能。
例如，可以重写速度更新方法以引入自适应惯性权重，或者重写位置更新方法以实现边界处理策略。
'''
pso = PSO.PSO(
    func=func,  # 目标函数
    dim=2,                # 优化变量维度（x1, x2 两个变量）
    pop=50,               # 粒子数量
    max_iter=100,         # 最大迭代次数
    lb=[-10, -10],        # 每个维度的下界：x1≥-10，x2≥-10
    ub=[10, 10],          # 每个维度的上界：x1≤10，x2≤10
    w=0.8,                # 惯性权重
    c1=0.5,               # 个体学习因子
    c2=0.5                # 群体学习因子
)

ans_x, ans_y = pso.run()
print("最优解位置：", ans_x)
print("最优解目标函数值：", ans_y)

plt.plot(pso.gbest_y_hist)
plt.xlabel('betch')
plt.ylabel('best_val')
plt.title('process')
plt.show()